\documentclass{article}

%table customization, stack overflow 
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\
\arraybackslash\hspace{0pt}}m{#1}}

%figure flaots from http://www.tex.ac.uk/FAQ-figurehere.HTML
\usepackage{float}

\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{url}
\usepackage{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}
\begin{document}
\pagenumbering{gobble}
\lhead{Team 6\\ JSTanks\\}
\newpage
\title{JSTanks - Design Document}
\date{November 6, 2016}
\author{Jiahao Li\\LI577\\001416646\and Pavithran Pathmarajah\\PATHMAP\\
001410729 \and Viren Patel\\PATELVH3\\001419057}

\maketitle

\newpage
\pagenumbering{arabic}
\tableofcontents

\newpage
\section{Revision History}
\subsection{Revision 0}
\begin{table}[H]
\caption{Revision History}
	\begin{tabularx}{\textwidth}{cXc}
		\toprule
		Date & Developer & Change\\
		\midrule
		November 6&Jiahao Li &Initial Draft \\
		November 6&Pavithran Pathmarajah &Initial Draft\\
		November 6&Viren Patel  &Initial Draft\\
	\end{tabularx}
\end{table}

\section{Introduction}
Module Decomposition is a good practice when it comes to developing applications involving many different data structures. Following this can benefit the program in many ways including the implementation process, maintenance, testing, and understanding of the program to new entities.\\ \\
Most programmers use the process of decomposing their program into different modules which represent different aspects of the program. This can allow the programmer to think of one module/aspect of the program at a time. Thus, simplifying the implementing process. \\ \\
It is easy to maintain a program which has its components implemented in separate modules. For example, the debugging process in case there are errors in the program, can be time consuming if the program has not been decomposed. On the other hand, a program that has been decomposed into modules would have the compiler point at the module in which the error occurs and therefore, the programmer only has to look through that module ignoring, but not completely, the code in the other modules.\\ \\
Testing is one of the most vital phases in the development process. A program which shows no module decomposition can make the testing process significantly tough for the programmer. This is because although he can test different functions of the program, he cannot tell if specific aspects of the program are working fine or not. In contrast, in a well decomposed program, the programmer can test out different modules and know for sure if they are working fine or not. He does not have to test the whole code in order to check a single module/aspect of the program. \\ \\
Module Decomposition makes it easier for stakeholders other than the developers, to understand the program and know how it accomplishes different tasks. They can learn about each module and connect them together to know how the program functions as one.\\ \\
This document is a Module Guide for JSTanks. JSTanks has followed the process the Module Decomposition greatly and can be seen in this doument.This document goes in to detail to show how the things mentioned in the Software Requirements Specifications document are accomplished in the program. We plan to use this document for all the purposes discussed above. \\ \\
This document has been divided into the following sections: Anticipated and Unlikely Changes of the software requirements, Module Hierarchy, Connection between Requirements and Design, Module Decomposition, Traceability Matrix, and Use Hierarchy between Modules.


\section{Anticipated and Unlikely Changes}
\subsection{Anticipated Changes}
\subsection{Unlikely Changes}

\section{Module Hierarchy}

\section{Connection between Requirements and Design}

\section{Module Decomposition}
\subsection{Hardware Hiding Modules}
\subsection{Behaviour Hiding Module}
\subsection{Software Decision Module}

\section{Traceability Matrix}
\begin{table}[!htbp]
      \begin{tabular}{ll}
        \toprule
        Requirement & Modules \\
        \midrule
        \multicolumn{2}{c}{Functional Requirements} \\
        \midrule
        FR1 & JSTanks.html \\
        FR2 & JSTanks.html \\
        FR3 & JSTanks.html, Tank.css, Game.js, GameBoard.js, barrier.js, \\
                 & createBoard.js, Tank.js, Bot.js, Overlay.js \\
        FR4 & Overlay.js \\
        FR5 & Overlay.js \\
        FR6 & Overlay.js \\
        FR7 & Overlay.js\\
        FR8 & Overlay.js \\
        FR9 & Overlay.js \\
        FR10 & Overlay.js \\
        FR11 & Overlay.js \\
        FR12 & Overlay.js \\
        FR13 & Bot.js, Projectile.js, Tank.js \\
        FR14 & Bot.js \\
        FR15 & Bot.js \\
        FR16 & Overlay.js \\
        FR17 & Player.js, Tank.js \\
        FR18 & Projectile.js \\
        FR19 & Projectile.js,Tank.js, Bot.js\\
        FR20 & GameBoard.js, barriers.js, Projectile.js\\
        FR21 & GameBoard.js, barriers.js, Projectile.js \\
        FR22 & GameBoard.js, barriers.js, Projectile.js \\
        FR23 & Projectile.js,Tank.js,Player.js  \\
        FR24 & EndGame.js \\
        FR25 & EndGame.js \\ \\
        \midrule
        \multicolumn{2}{c}{Non-functional Requirements} \\
        \midrule
        NF1.1 & JSTanks.html, Tank.css, Game.js, GameBoard.js, barriers.js,\\
                     & createBoard.js, Tank.js, Bot.js \\
        NF1.2 & JSTanks.html, Tank.css, Game.js, GameBoard.js, Tank.js, \\
                     & Bot.js, Overlay.js \\
        NF2.1 & Tank.js, Player.js, Projectile.js \\
        NF2.2 & -- \\
        NF2.3 & JSTanks.html \\
        NF2.4& Overlay.js \\
        NF2.5 & -- \\
        NF3 & -- \\
        NF4 &JSTanks.html, Tank.css \\
        NF5 & Game.js, GameBoard.js, Tank.js, Player.js, Bot.js, Overlay.js, \\
                 &barrier.js, createBoard.js, Projectile.js \\
        NF6 & -- \\
        NF7 & Overlay.js \\
        NF8 & -- \\
        \bottomrule
        \end{tabular}
        \caption{Trace Between Requirements and Modules}
        % Colour for the rulings in tables:
        \makeatletter
           \def\rulecolor#1#{\CT@arc{#1}}
           \def\CT@arc#1#2{%
           \ifdim\baselineskip=\z@\noalign\fi
           {\gdef\CT@arc@{\color#1{#2}}}}
           \let\CT@arc@\relax
          \rulecolor{black!50}
        \makeatother
        \label{Table 2}
        \end{table}
\section{Use Relations}

\newpage
% Revision History, Module Hierarchy, Trace between Requirements and Modules, Trace between Anticipated Changes and Modules
\listoftables
% Use hierarchy among modules
\listoffigures

\end{document}